#!/bin/bash
VERSION="1.0.2"

# Параметры по умолчанию
IMPORT_DIR=$(pwd)
echo $IMPORT_DIR

IMPORT_DB_HOST="localhost"
IMPORT_DB_PORT="5432"
IMPORT_DB_NAME=""
IMPORT_DB_USER="postgres"
CREATE_DB=true
DROP_IF_EXISTS=false
VERBOSE=false
SKIP_SCHEMA=false
SKIP_DATA=false
BATCH_SIZE=10000

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Функция для вывода справки
show_help() {
    cat << EOF
Скрипт для восстановления базы данных PostgreSQL из бинарного формата

Использование: $(basename "$0") [ПАРАМЕТРЫ]

Обязательные параметры:
  -i, --input DIR         Директория с файлами экспорта (содержит metadata.json)
  -d, --dbname NAME       Имя базы данных для восстановления

Основные параметры:
  -h, --host HOST         Хост PostgreSQL (по умолчанию: $IMPORT_DB_HOST)
  -p, --port PORT         Порт PostgreSQL (по умолчанию: $IMPORT_DB_PORT)
  -u, --username USER     Имя пользователя PostgreSQL (по умолчанию: $IMPORT_DB_USER)
  -c, --create            Создать базу данных если не существует (по умолчанию: включено)
  -n, --no-create         Не создавать базу данных автоматически
  -D, --drop              Удалить существующую базу данных перед восстановлением
  -S, --skip-schema       Пропустить восстановление схемы (только данные)
  -T, --skip-data         Пропустить восстановление данных (только схема)
  -b, --batch-size N      Размер пакета для импорта больших таблиц (по умолчанию: $BATCH_SIZE)
  -v, --verbose           Подробный вывод
  --help                  Показать эту справку

Примеры:
  # Восстановить базу из директории экспорта
  $(basename "$0") -i /backups/mydb_20240115_143022 -d mydb_restored
  
  # Восстановить с удалением существующей базы
  $(basename "$0") -i ./export -d mydb -h db.example.com -D
  
  # Восстановить только схему
  $(basename "$0") -i ./export -d mydb -T
  
  # Восстановить только данные (предполагая, что схема уже существует)
  $(basename "$0") -i ./export -d mydb -S
  
  # Подробный вывод с пакетным импортом
  $(basename "$0") -i ./export -d large_db -b 50000 -v

Примечания:
  1. Директория импорта должна содержать файл metadata.json
  2. Для аутентификации используйте ~/.pgpass или переменную PGPASSWORD
  3. Перед восстановлением рекомендуется сделать резервную копию существующих данных
  4. При использовании --drop будьте осторожны, данные будут удалены безвозвратно
EOF
    exit 0
}

# Функции для вывода
log_info() {
    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_debug() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    fi
}

# Функция для проверки зависимостей
check_dependencies() {
    local missing_deps=()
    
    # Проверяем psql
    if ! command -v psql &> /dev/null; then
        missing_deps+=("psql (PostgreSQL client)")
    fi
    
    # Проверяем jq для чтения metadata.json
    #if ! command -v jq &> /dev/null; then
    #    missing_deps+=("jq (JSON processor)")
    #fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Отсутствуют необходимые зависимости:"
        for dep in "${missing_deps[@]}"; do
            log_error "  - $dep"
        done
        log_error ""
        log_error "Установите их с помощью пакетного менеджера вашей системы:"
        log_error "  Ubuntu/Debian: sudo apt-get install postgresql-client jq"
        log_error "  CentOS/RHEL:   sudo yum install postgresql jq"
        log_error "  macOS:         brew install postgresql jq"
        return 1
    fi
    
    log_debug "Все зависимости найдены"
    return 0
}

# Функция для проверки директории импорта
check_import_directory() {
    if [[ ! -d "$IMPORT_DIR" ]]; then
        log_error "Директория импорта не существует: $IMPORT_DIR"
        return 1
    fi
    
    #local metadata_file="$IMPORT_DIR/metadata.json"
    #if [[ ! -f "$metadata_file" ]]; then
    #    log_error "Файл metadata.json не найден в директории: $IMPORT_DIR"
    #    log_error "Убедитесь, что выбрана правильная директория экспорта"
    #    return 1
    #fi
    
    # Проверяем, что metadata.json валидный JSON
    #if ! jq empty "$metadata_file" 2>/dev/null; then
    #    log_error "Файл metadata.json содержит невалидный JSON"
    #    return 1
    #fi
    
    log_debug "Директория импорта проверена: $IMPORT_DIR"
    return 0
}

# Функция для проверки подключения к PostgreSQL
check_postgres_connection() {
    log_info "Проверка подключения к PostgreSQL..."
    
    # Пробуем подключиться к серверу PostgreSQL
    if ! PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
        -U "$IMPORT_DB_USER" -c "SELECT version();" > /dev/null 2>&1; then
        log_error "Не удалось подключиться к серверу PostgreSQL"
        log_error "Параметры подключения:"
        log_error "  Хост: $IMPORT_DB_HOST"
        log_error "  Порт: $IMPORT_DB_PORT"
        log_error "  Пользователь: $IMPORT_DB_USER"
        log_error ""
        log_error "Возможные причины:"
        log_error "1. Сервер PostgreSQL не запущен"
        log_error "2. Неправильные параметры подключения"
        log_error "3. Проблемы с аутентификацией"
        log_error "4. Ограничения доступа в pg_hba.conf"
        return 1
    fi
    
    log_info "Подключение к серверу PostgreSQL успешно"
    return 0
}

# Функция для проверки существования базы данных
check_database_exists() {
    local db_exists=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
        -U "$IMPORT_DB_USER" -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$IMPORT_DB_NAME" && echo "true" || echo "false")
    
    if [[ "$db_exists" == "true" ]]; then
        log_info "База данных '$IMPORT_DB_NAME' существует"
        
        if [[ "$DROP_IF_EXISTS" == true ]]; then
            log_warn "База данных будет удалена (используется параметр --drop)"
            
            # Запрашиваем подтверждение
            if [[ -t 0 ]]; then  # Проверяем, что stdin является терминалом
                read -p "Вы уверены, что хотите удалить базу данных '$IMPORT_DB_NAME'? [y/N]: " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    log_error "Восстановление отменено пользователем"
                    exit 1
                fi
            fi
            
            # Удаляем базу данных
            log_info "Удаление базы данных '$IMPORT_DB_NAME'..."
            if ! PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
                -U "$IMPORT_DB_USER" -c "DROP DATABASE IF EXISTS \"$IMPORT_DB_NAME\" WITH (FORCE);" 2>&1; then
                log_error "Не удалось удалить базу данных '$IMPORT_DB_NAME'"
                return 1
            fi
            
            log_info "База данных '$IMPORT_DB_NAME' удалена"
            return 2  # Код 2 означает, что база была удалена
        else
            if [[ "$CREATE_DB" == false ]]; then
                log_warn "База данных уже существует, но параметр --no-create запрещает её перезапись"
                return 0
            else
                log_warn "База данных уже существует, данные будут добавлены в существующую базу"
                return 0
            fi
        fi
    else
        log_info "База данных '$IMPORT_DB_NAME' не существует"
        return 1
    fi
}

# Функция для создания базы данных
create_database() {
    log_info "Создание базы данных '$IMPORT_DB_NAME'..."
    
    if ! PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
        -U "$IMPORT_DB_USER" -c "CREATE DATABASE \"$IMPORT_DB_NAME\";" 2>&1; then
        log_error "Не удалось создать базу данных '$IMPORT_DB_NAME'"
        return 1
    fi
    
    log_info "База данных '$IMPORT_DB_NAME' создана"
    return 0
}

# Функция для восстановления схемы
restore_schema() {
    local schema_file="$IMPORT_DIR/schema.sql"
    
    if [[ ! -f "$schema_file" ]]; then
        log_warn "Файл схемы не найден: $schema_file"
        log_warn "Пропускаю восстановление схемы"
        return 0
    fi
    
    log_info "Восстановление схемы базы данных..."
    
    # Проверяем размер файла схемы
    local schema_size=$(stat -c%s "$schema_file" 2>/dev/null || echo "0")
    if [[ "$schema_size" -eq 0 ]]; then
        log_warn "Файл схемы пустой"
        return 0
    fi
    
    # Восстанавливаем схему
    local start_time=$(date +%s.%N)
    
    if ! PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
        -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -f "$schema_file" 2>&1; then
        log_warn "При восстановлении схемы возникли ошибки (возможно, объекты уже существуют)"
        
        # Пытаемся восстановить построчно для выявления конкретных ошибок
        if [[ "$VERBOSE" == true ]]; then
            log_debug "Попытка восстановления схемы построчно..."
            local line_num=0
            while IFS= read -r line || [[ -n "$line" ]]; do
                line_num=$((line_num + 1))
                if [[ -n "$line" ]] && [[ ! "$line" =~ ^-- ]]; then  # Пропускаем пустые строки и комментарии
                    if ! PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
                        -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c "$line" 2>/dev/null; then
                        log_debug "Ошибка в строке $line_num: $line"
                    fi
                fi
            done < "$schema_file"
        fi
    fi
    
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)
    
    log_info "Схема восстановлена за ${duration}s"
    return 0
}

# Функция для чтения метаданных
read_metadata() {
    #local metadata_file="$IMPORT_DIR/metadata.json"
    
    log_debug "Поиск файлов .table.txt в каталоге: $metadata_file"
    
    # Получаем количество таблиц
    #TABLE_COUNT=$(jq 'length' "$metadata_file" 2>/dev/null || echo "0")
    
    #if [[ "$TABLE_COUNT" -eq 0 ]]; then
    #    log_warn "В metadata.json не найдено таблиц"
    #    return 1
    #fi
    
    log_info "Найдено таблиц для импорта: $TABLE_COUNT"
    
    # Читаем информацию о таблицах в массив
    TABLE_NAMES=()
    TABLE_FILES=()
    TABLE_ROWS=()

TABLE_COUNT=0

# Безопасный поиск файлов (обрабатывает пробелы в именах)
while IFS= read -r file; do
    ((TABLE_COUNT++))
    table=$(sed -n '2p' "$file" 2>/dev/null || echo "")
    filename=$(sed -n '4p' "$file" 2>/dev/null || echo "")
    row_count=$(sed -n '6p' "$file" 2>/dev/null || echo "")
    file_size=$(sed -n '8p' "$file" 2>/dev/null || echo "")
            
    TABLE_NAMES+=("$table")
    TABLE_FILES+=("$filename")
    TABLE_ROWS+=("$row_count")
    
log_debug "Таблица $((i+1)): $table -> $filename (строк: $row_count)"
    
done < <(find "$IMPORT_DIR" -type f -name "*.table.txt" 2>/dev/null)

    
    #for ((i=0; i<TABLE_COUNT; i++)); do
    #    local table=$(jq -r ".[$i].table" "$metadata_file" 2>/dev/null)
    #    local filename=$(jq -r ".[$i].filename" "$metadata_file" 2>/dev/null)
    #    local row_count=$(jq -r ".[$i].row_count" "$metadata_file" 2>/dev/null)
    #    
    #    if [[ -n "$table" ]] && [[ -n "$filename" ]]; then
    #        TABLE_NAMES+=("$table")
    #        TABLE_FILES+=("$filename")
    #        TABLE_ROWS+=("$row_count")
    #        
    #        log_debug "Таблица $((i+1)): $table -> $filename (строк: $row_count)"
    #    else
    #        log_warn "Пропущена запись $((i+1)) в metadata.json (неполные данные)"
    #    fi
    #done
    
    # Обновляем количество таблиц с учетом пропущенных
    #TABLE_COUNT=${#TABLE_NAMES[@]}
    
    #if [[ "$TABLE_COUNT" -eq 0 ]]; then
    #    log_error "Не удалось загрузить информацию о таблицах из metadata.json"
    #    return 1
    #fi
    
    log_info "Успешно загружено таблиц: $TABLE_COUNT"
    return 0
}

# Функция для проверки наличия файлов данных
check_data_files() {
    log_info "Проверка наличия файлов данных..."
    
    local missing_files=0
    
    for ((i=0; i<TABLE_COUNT; i++)); do
        local filename="${TABLE_FILES[$i]}"
        local data_file="$IMPORT_DIR/$filename"
        
        if [[ ! -f "$data_file" ]]; then
            log_warn "Файл данных не найден: $data_file (таблица: ${TABLE_NAMES[$i]})"
            missing_files=$((missing_files + 1))
        elif [[ ! -s "$data_file" ]]; then
            log_warn "Файл данных пустой: $data_file (таблица: ${TABLE_NAMES[$i]})"
        fi
    done
    
    if [[ $missing_files -gt 0 ]]; then
        log_warn "Не найдено файлов данных: $missing_files"
        
        if [[ $missing_files -eq $TABLE_COUNT ]]; then
            log_error "Не найдены ни один из файлов данных"
            return 1
        fi
    fi
    
    log_info "Проверка файлов данных завершена"
    return 0
}

# Функция для импорта одной таблицы
import_table() {
    local table_name="$1"
    local data_file="$2"
    local expected_rows="$3"
    local table_index="$4"
    
    if [[ ! -f "$data_file" ]]; then
        log_warn "Файл не существует: $data_file (пропускаю таблицу: $table_name)"
        return 1
    fi
    
    if [[ ! -s "$data_file" ]]; then
        log_debug "Файл пустой: $data_file (пропускаю таблицу: $table_name)"
        return 0
    fi
    
    # Показываем прогресс
    local progress=$(( (table_index * 100) / TABLE_COUNT ))
    printf "\rИмпорт таблиц: [%-50s] %3d%% (%d/%d) %-30s" \
        "$(printf '#%.0s' $(seq 1 $((progress/2))))" \
        "$progress" "$((table_index+1))" "$TABLE_COUNT" "$table_name"
    
    local start_time=$(date +%s.%N)
    local file_size=$(stat -c%s "$data_file" 2>/dev/null || echo "0")
    
echo ""

    log_debug "Импорт таблицы: $table_name (файл: $data_file, размер: $((file_size/1024/1024))MB)"
    echo "Импорт таблицы: $table_name (файл: $data_file, размер: $((file_size/1024/1024))MB)"
    
#    # Проверяем существование таблицы
#    local table_exists=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
#        -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -t -c \
#        "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema || '.' || table_name = '$table_name');" 2>/dev/null | tr -d ' ' | grep -i true)
#    
#    if [[ -z "$table_exists" ]]; then
#        log_warn "Таблица $table_name не существует в базе данных"
#        
#        # Пытаемся создать таблицу на лету (если есть информация о схеме)
#        if [[ "$SKIP_SCHEMA" == false ]]; then
#            log_debug "Попытка создания таблицы $table_name..."
#            
#            # Извлекаем schema и table name
#            local schema=$(echo "$table_name" | cut -d'.' -f1)
#            local table=$(echo "$table_name" | cut -d'.' -f2)
#            
#            # Пытаемся создать простую таблицу (как запасной вариант)
#            PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
#                -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c \
#                "CREATE SCHEMA IF NOT EXISTS \"$schema\";" 2>/dev/null
#        else
#            log_error "Невозможно импортировать данные в несуществующую таблицу $table_name"
#            return 1
#        fi
#    fi
    
    # Импортируем данные
    local import_result
    local error_output
    
    # Используем временный файл для сбора ошибок
#    local error_file=$(mktemp)
    local error_file="$IMPORT_DIR"/IMPORT_errors.log
    #echo $error_file

    if [[ "$BATCH_SIZE" -gt 0 ]] && [[ "$expected_rows" -gt "$BATCH_SIZE" ]]; then
        # Пакетный импорт для больших таблиц
        import_result=$(import_table_in_batches "$table_name" "$data_file" "$expected_rows" "$error_file")
    else
        # Обычный импорт
#        import_result=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
#            -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c \
#            "COPY \"$(echo "$table_name" | sed 's/\"/\"\"/g')\" FROM STDIN WITH (FORMAT BINARY);" \
#            < "$data_file" 2>"$error_file" && echo "success" || echo "error")

#        import_result=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
#            -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c \
#            "COPY $table_name FROM '$data_file' WITH (FORMAT BINARY);" )
##	     2>"$error_file" && echo "success" || echo "error")

#        import_result=$(PGPASSWORD="$PGPASSWORD" 

#echo "COPY $table_name FROM '$data_file' WITH (FORMAT BINARY);"

echo "psql -h '$IMPORT_DB_HOST' -p '$IMPORT_DB_PORT' -U '$IMPORT_DB_USER' -d 'IMPORT_DB_NAME' -c 'COPY $table_name FROM '$data_file' WITH (FORMAT BINARY);' ";

        import_result=$(PGPASSWORD="$PGPASSWORD" \
	psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
            -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c \
            "COPY $table_name FROM '$data_file' WITH (FORMAT BINARY);" \
	     2>&1 > "$error_file" && echo "success" || echo "error")

echo "import result is " $import_result;

	#2>"$error_file"

#)
#	     2>"$error_file" && echo "success" || echo "error")

#
#	import_result=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
#            -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c \
#            "COPY $table_name FROM STDIN WITH (FORMAT BINARY);" \
#            < "$data_file")
# > errors.txt\
#2>"$error_file" && echo "success" || echo "error"
#)

        #echo "psql -h $IMPORT_DB_HOST -p $IMPORT_DB_PORT \
        #    -U $IMPORT_DB_USER -d $IMPORT_DB_NAME -c \
        #    COPY $table_name FROM STDIN WITH";
        #echo $data_file;
    fi
    
    # Читаем ошибки если есть
    error_output=$(cat "$error_file")
    rm -f "$error_file"
    
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)
    
    if [[ "$import_result" == "success" ]]; then
        # Проверяем количество импортированных строк
        local actual_rows=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
            -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -t -c \
            "SELECT COUNT(*) FROM "$table_name";" 2>/dev/null | tr -d ' ' | grep -v '^$' || echo "0")
#        local actual_rows=$(PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
#            -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -t -c \
#            "SELECT COUNT(*) FROM \"$(echo "$table_name" | sed 's/\"/\"\"/g')\";" 2>/dev/null | tr -d ' ' | grep -v '^$' || echo "0")
        
        if [[ "$VERBOSE" == true ]]; then
            printf "\rИмпорт таблиц: [%-50s] %3d%% (%d/%d) %-30s [OK: %s строк за %.1fs]\n" \
                "$(printf '#%.0s' $(seq 1 $((progress/2))))" \
                "$progress" "$((table_index+1))" "$TABLE_COUNT" "$table_name" "$actual_rows" "$duration"
        fi
        
        echo "Импортировано строк: $actual_rows (ожидалось: $expected_rows) за ${duration}s"
        log_debug "Импортировано строк: $actual_rows (ожидалось: $expected_rows) за ${duration}s"

        if [[ "$actual_rows" -eq "$expected_rows" ]]; then
            log_debug "✓ Проверка пройдена: количество строк совпадает"
        else
            log_warn "⚠ Количество строк не совпадает: импортировано $actual_rows, ожидалось $expected_rows"
        fi
        
        return 0
    else
        if [[ "$VERBOSE" == true ]]; then
            printf "\rИмпорт таблиц: [%-50s] %3d%% (%d/%d) %-30s [ERROR]\n" \
                "$(printf '#%.0s' $(seq 1 $((progress/2))))" \
                "$progress" "$((table_index+1))" "$TABLE_COUNT" "$table_name"
        fi
        
        log_error "Ошибка импорта таблицы $table_name: $error_output"
        return 1
    fi
}

# Функция для пакетного импорта больших таблиц
import_table_in_batches() {
    local table_name="$1"
    local data_file="$2"
    local total_rows="$3"
    local error_file="$4"
    
    log_debug "Пакетный импорт таблицы $table_name (всего строк: $total_rows, пакет: $BATCH_SIZE)"
    
    # Создаем временный файл для разбивки
    local temp_dir=$(mktemp -d)
    
    # Разбиваем бинарный файл - это сложно, поэтому просто импортируем целиком
    # В реальном скрипте здесь должна быть более сложная логика
    
    # Для упрощения импортируем целиком
    PGPASSWORD="$PGPASSWORD" psql -h "$IMPORT_DB_HOST" -p "$IMPORT_DB_PORT" \
        -U "$IMPORT_DB_USER" -d "$IMPORT_DB_NAME" -c \
        "COPY \"$(echo "$table_name" | sed 's/\"/\"\"/g')\" FROM STDIN WITH (FORMAT BINARY);" \
        < "$data_file" 2>"$error_file"
    
    local result=$?
    
    # Очищаем временные файлы
    rm -rf "$temp_dir"
    
    return $result
}

# Функция для создания отчета о восстановлении
create_restore_report() {
    local report_file="$IMPORT_DIR/restore_report_$(date +%Y%m%d_%H%M%S).txt"
    
    cat > "$report_file" << REPORT_EOF
Отчет о восстановлении базы данных
===================================

Дата восстановления: $(date)
Восстановленная база данных: $IMPORT_DB_NAME
Директория импорта: $IMPORT_DIR
Хост PostgreSQL: $IMPORT_DB_HOST:$IMPORT_DB_PORT
Пользователь: $IMPORT_DB_USER

Статистика восстановления:
  Всего таблиц в метаданных: $TOTAL_TABLES_METADATA
  Успешно восстановлено: $SUCCESS_COUNT
  Не удалось восстановить: $FAIL_COUNT
  Пропущено: $((TOTAL_TABLES_METADATA - SUCCESS_COUNT - FAIL_COUNT))

Параметры восстановления:
  Создание БД: $([ "$CREATE_DB" == true ] && echo "Да" || echo "Нет")
  Удаление существующей БД: $([ "$DROP_IF_EXISTS" == true ] && echo "Да" || echo "Нет")
  Восстановление схемы: $([ "$SKIP_SCHEMA" == false ] && echo "Да" || echo "Нет")
  Восстановление данных: $([ "$SKIP_DATA" == false ] && echo "Да" || echo "Нет")
  Размер пакета: $BATCH_SIZE
  Подробный режим: $([ "$VERBOSE" == true ] && echo "Да" || echo "Нет")

Детали по таблицам:
REPORT_EOF
    
    # Добавляем информацию по каждой таблице
    for ((i=0; i<TABLE_COUNT; i++)); do
        local status="OK"
        if [[ ${IMPORT_RESULTS[$i]} -ne 0 ]]; then
            status="ERROR"
        fi
        
        echo "  $((i+1)). ${TABLE_NAMES[$i]} - ${status}" >> "$report_file"
    done
    
    # Добавляем общее время выполнения
    echo "" >> "$report_file"
    echo "Общее время восстановления: ${RESTORE_DURATION}s" >> "$report_file"
    
    # Добавляем рекомендации
    echo "" >> "$report_file"
    echo "Рекомендации:" >> "$report_file"
    echo "1. Проверьте целостность восстановленных данных" >> "$report_file"
    echo "2. Протестируйте работу приложения с восстановленной базой" >> "$report_file"
    echo "3. Создайте резервную копию восстановленной базы" >> "$report_file"
    
    log_info "Отчет о восстановлении сохранен: $report_file"
}

# Основная функция восстановления
main_restore() {
    local start_time=$(date +%s.%N)
    
    log_info "Начало восстановления базы данных PostgreSQL"
    log_info "=============================================="
    
    # Разбор аргументов командной строки
    parse_arguments "$@"
    
    # Проверяем обязательные параметры
    if [[ -z "$IMPORT_DIR" ]] || [[ -z "$IMPORT_DB_NAME" ]]; then
        log_error "Не указаны обязательные параметры"
        echo "Используйте --help для просмотра справки"
        exit 1
    fi
    
    # Проверяем зависимости
    if ! check_dependencies; then
        exit 1
    fi
    
    # Проверяем директорию импорта
    if ! check_import_directory; then
        exit 1
    fi
    
    # Проверяем подключение к PostgreSQL
    if ! check_postgres_connection; then
        exit 1
    fi
    
    # Проверяем/создаем базу данных
    local db_status
    check_database_exists
    db_status=$?
    
    case $db_status in
        0)  # База существует, не удаляли
            if [[ "$CREATE_DB" == false ]]; then
                log_error "База данных существует, но запрещено использование существующей"
                log_error "Используйте --drop для удаления или --create для разрешения использования"
                exit 1
            fi
            ;;
        1)  # База не существует
            if [[ "$CREATE_DB" == true ]]; then
                if ! create_database; then
                    exit 1
                fi
            else
                log_error "База данных не существует, но запрещено её создание"
                log_error "Используйте --create для разрешения создания базы"
                exit 1
            fi
            ;;
        2)  # База была удалена, нужно создать
            if ! create_database; then
                exit 1
            fi
            ;;
    esac
    
    # Восстанавливаем схему если нужно
    if [[ "$SKIP_SCHEMA" == false ]]; then
        if ! restore_schema; then
            log_warn "Возникли проблемы при восстановлении схемы"
        fi
    else
        log_info "Восстановление схемы пропущено (параметр --skip-schema)"
    fi
    
    # Если нужно пропустить данные, завершаем здесь
    if [[ "$SKIP_DATA" == true ]]; then
        log_info "Восстановление данных пропущено (параметр --skip-data)"
        
        local end_time=$(date +%s.%N)
        RESTORE_DURATION=$(echo "$end_time - $start_time" | bc)
        
        log_info "=============================================="
        log_info "Восстановление схемы завершено за ${RESTORE_DURATION}s"
        log_info "База данных: $IMPORT_DB_NAME"
        exit 0
    fi
    
    # Читаем метаданные
    if ! read_metadata; then
        log_error "Не удалось прочитать метаданные"
        exit 1
    fi
    
    TOTAL_TABLES_METADATA=$TABLE_COUNT
    
    # Проверяем файлы данных
    if ! check_data_files; then
        log_warn "Обнаружены проблемы с файлами данных"
    fi
    
    # Импортируем таблицы
    log_info "Начало импорта данных..."
    echo ""
    
    IMPORT_RESULTS=()
    SUCCESS_COUNT=0
    FAIL_COUNT=0
    

TABLE_COUNT=0

# Безопасный поиск файлов (обрабатывает пробелы в именах)
while IFS= read -r file; do
    ((TABLE_COUNT++))
    table_name1=$(sed -n '2p' "$file" 2>/dev/null || echo "")
    table_name="${table_name1/public./}"
    data_file=$(sed -n '4p' "$file" 2>/dev/null || echo "")
    expected_rows=$(sed -n '6p' "$file" 2>/dev/null || echo "")
    file_size=$(sed -n '8p' "$file" 2>/dev/null || echo "")

        if import_table "$table_name" "$IMPORT_DIR"/"$data_file" "$expected_rows" "$TABLE_COUNT"; then
            IMPORT_RESULTS[$i]=0
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
            IMPORT_RESULTS[$i]=1
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi
    
log_debug "Таблица $((i+1)): $table -> $filename (строк: $row_count)"
    
done < <(find "$IMPORT_DIR" -type f -name "*.table.txt" 2>/dev/null)

#    for ((i=0; i<TABLE_COUNT; i++)); do
#        local table_name="${TABLE_NAMES[$i]}"
#        local data_file="$IMPORT_DIR/${TABLE_FILES[$i]}"
#        local expected_rows="${TABLE_ROWS[$i]}"
#
#        if import_table "$table_name" "$data_file" "$expected_rows" "$i"; then
#            IMPORT_RESULTS[$i]=0
#            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
#        else
#            IMPORT_RESULTS[$i]=1
#            FAIL_COUNT=$((FAIL_COUNT + 1))
#        fi
#    done
    
    # Завершаем прогресс-бар
    #printf "\rИмпорт таблиц: [%-50s] 100%% (%d/%d)\n" \
    #    "$(printf '#%.0s' $(seq 1 50))" "$TABLE_COUNT" "$TABLE_COUNT"
    
    echo ""
    
    # Завершаем время выполнения
    local end_time=$(date +%s.%N)
    RESTORE_DURATION=$(echo "$end_time - $start_time" | bc)
    
    # Выводим итоговую статистику
    log_info "=============================================="
    log_info "Восстановление завершено!"
    log_info "Общее время: ${RESTORE_DURATION}s"
    log_info "Статистика:"
    log_info "  Успешно: $SUCCESS_COUNT таблиц"
    log_info "  Неудачно: $FAIL_COUNT таблиц"
    log_info "  Всего: $TABLE_COUNT таблиц"
    log_info ""
    log_info "База данных восстановлена: $IMPORT_DB_NAME"
    log_info "Хост: $IMPORT_DB_HOST:$IMPORT_DB_PORT"
    log_info "=============================================="
    
    # Создаем отчет если есть ошибки или в verbose режиме
    if [[ $FAIL_COUNT -gt 0 ]] || [[ "$VERBOSE" == true ]]; then
        create_restore_report
    fi
    
    # Проверяем общее состояние базы данных
    if [[ $FAIL_COUNT -eq 0 ]]; then
        log_info "✅ Все таблицы успешно восстановлены"
    elif [[ $FAIL_COUNT -eq $TABLE_COUNT ]]; then
        log_error "❌ Не удалось восстановить ни одной таблицы"
        exit 1
    else
        log_warn "⚠ Восстановление завершено с ошибками ($FAIL_COUNT из $TABLE_COUNT таблиц)"
        log_warn "   Проверьте логи и отчет для деталей"
    fi
    
    # Выводим команду для проверки базы данных
    echo ""
    log_info "Для проверки базы данных выполните:"
    log_info "  psql -h $IMPORT_DB_HOST -p $IMPORT_DB_PORT -U $IMPORT_DB_USER -d $IMPORT_DB_NAME"
}

# Функция для разбора аргументов командной строки
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -i|--input)
                if [[ -z "$2" || "$2" == -* ]]; then
                    log_error "Параметр $1 требует значение"
                    exit 1
                fi
                IMPORT_DIR="$2"
                shift 2
                ;;
            -d|--dbname)
                if [[ -z "$2" || "$2" == -* ]]; then
                    log_error "Параметр $1 требует значение"
                    exit 1
                fi
                IMPORT_DB_NAME="$2"
                shift 2
                ;;
            -h|--host)
                if [[ -z "$2" || "$2" == -* ]]; then
                    log_error "Параметр $1 требует значение"
                    exit 1
                fi
                IMPORT_DB_HOST="$2"
                shift 2
                ;;
            -p|--port)
                if [[ -z "$2" || "$2" == -* ]]; then
                    log_error "Параметр $1 требует значение"
                    exit 1
                fi
                IMPORT_DB_PORT="$2"
                shift 2
                ;;
            -u|--username)
                if [[ -z "$2" || "$2" == -* ]]; then
                    log_error "Параметр $1 требует значение"
                    exit 1
                fi
                IMPORT_DB_USER="$2"
                shift 2
                ;;
            -c|--create)
                CREATE_DB=true
                shift
                ;;
            -n|--no-create)
                CREATE_DB=false
                shift
                ;;
            -D|--drop)
                DROP_IF_EXISTS=true
                shift
                ;;
            -S|--skip-schema)
                SKIP_SCHEMA=true
                shift
                ;;
            -T|--skip-data)
                SKIP_DATA=true
                shift
                ;;
            -b|--batch-size)
                if [[ -z "$2" || "$2" == -* ]]; then
                    log_error "Параметр $1 требует значение"
                    exit 1
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    log_error "Размер пакета должен быть числом"
                    exit 1
                fi
                BATCH_SIZE="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --help)
                show_help
                ;;
            -*)
                log_error "Неизвестный параметр: $1"
                echo "Используйте --help для просмотра справки"
                exit 1
                ;;
            *)
                log_error "Неожиданный аргумент: $1"
                exit 1
                ;;
        esac
    done
}

# Обработка сигналов
trap 'echo -e "\n\n${RED}Восстановление прервано${NC}"; exit 1' INT TERM

# Запуск основной функции
echo $IMPORT_DIR
main_restore "$@"